---
title: 每周见闻(36)：Node.js 其实也有多线程
date: 2025-10-06 19:57:27
toc: true
---

每周见闻：2025-09-28 - 2025-10-05

假期前三天还在处理之前生产事故，这次真是血的教训。等事情告一段落之后，再来好好复盘一下。

后面两天稍微能休息一下了，就把之前收藏的技术博客好好读了读。因为目前主要以 Node.js 为主，所以这期关于 Node.js 的文章会比较多。

## Coding
**1、[Stop using .reverse().find(): meet findLast() - Matt Smith](https://allthingssmitty.com/2025/09/22/stop-using-reverse-find-meet-findlast/)[^1]**

标签：Node.js,JavaScript

获取数组最后一个元素的 API `findLast` 以及 `findLastIndex` 可以告别 `reserve().find()` 的用法了。Node 18+ 以及 Chrome 97+ 都以支持。

这个在很多业务场景中很实用，而且可以避免 .reverse 对原数组的修改，副作用更小。

```JavaScript
// 可以告别这种方式了
const lastError = [...logs].reverse().find(log => log.type === 'error'); 

// 现在可以这样写了
const messages = [
  { id: 1, text: 'Hello', read: true },
  { id: 2, text: 'Hi', read: false },
  { id: 3, text: 'Hey', read: true },
];

const lastUnread = messages.findLast(msg => !msg.read);

console.log(lastUnread);
// { id: 2, text: 'Hi', read: false }
```

**2、[Worker Threads in Node.js: A Complete Guide for Multithreading in JavaScript](https://nodesource.com/blog/worker-threads-nodejs-multithreading-in-javascript)[^2]**

标签：Node.js,JavaScript

这篇文章介绍了如何在 Node.js 中使用多线程。众所周知，Node.js 是单线程运行，在遇到 CPU 密集型任务时就有些吃紧了。利用 `Worker Threads` 模块，可以在主线程外运行 Node.js 代码。比如图像/视频的解码、数据转换、复杂的数学计算以及机器学习任务。

肯定有小伙伴会问 Node 不是有 `child_process` 模块么？`child_process` 是另外开一个进程，可以认为是两个独立的 Node 程序。而 `Worker Threads` 最大的区别就是可以共享内存空间，从开销上来说比 `child_process` 更节省。

文中给出了详细的例子，并且指出了一些常见的陷阱：
1. 不要对 I/O 密集型的任务使用 Worker Threads
2. 不要创建太多 Worker，太多的 Worker 反而会降低性能。可以考虑使用 Worker 池
3. 当数据量较大时，使用 SharedArrayBuffer 共享数据

| Feature        | worker_threads                     | child_process               |
| -------------- | ---------------------------------- | --------------------------- |
| Memory Sharing | Yes (via SharedArrayBuffer)        | No                          |
| Overhead       | Low                                | Higher (spawns new process) |
| Use Case       | CPU-bound tasks                    | I/O-bound tasks, CLI tools  |
| Communication  | Message passing, SharedArrayBuffer | IPC or stdout/stderr        |

**3、[Mastering NPX: A Cheatsheet for npm and Node.js Power Users](https://www.nodejs-security.com/blog/mastering-npx-cheatsheet-npm-nodejs-power-users)[^4]**

标签：Node.js

一篇关于 npx 的速查手册。Node 开发的小伙伴对 npx 肯定不陌生。这个命令允许开发者直接从 npm 仓库执行包，而无需全局安装它们。这对于运行一次性命令或测试包而不会污染您的全局命名空间特别有用如 `npx create-react-app my-new-app` 。

除此之外，npx 还可以指定 Node 版本来运行。这对于测试兼容性很有帮助。

`npx -p node@14 command`

鉴于之前的 NPM 漏洞，在执行 npx 命令时还是应当多加小心。

**4、[How Deno protects against npm exploits | Deno](https://deno.com/blog/deno-protects-npm-exploits)[^5]**

标签：Deno,Node.js

这篇文章介绍 Deno 是如何防范 NPM 的恶意应用。

此前两周 NPM 发生的两大安全漏洞（@ctrl/tinycolor 通过 postinstall 窃取信息）造成不小的影响，也让开发者重新意识到 NPM 上的包并非 100% 安全。其主要原因在于 Node 和 NPM 的默认安全模型非常宽松，第三方的依赖可以无限制地读取或运行程序。

Deno 由于默认不给任何权限，因此天然地能减少和降低恶意三方依赖带来的危害。甚至还能精细地控制访问权限。不过这对开发效率就会造成影响，一旦开发者偷懒开放了全部授权，那么这些措施仍然是形同虚设。

所谓开发效率和开发安全不能两者兼得啊。

| Permission it grants | Flag | Shorthand |
| --- | --- | --- |
| Read access to the file system | `--allow-read` | `-R` |
| Write access to the file system | `--allow-write` | `-W` |
| Network access | `--allow-net` | `-N` |
| Access to environment variables | `--allow-env` | `-E` |
| Run subprocesses | `--allow-run` | none |
| All permissions (disable sandbox) | `--allow-all` | `-A` |

----

## AI
**1、[程序员的提示工程实战手册](https://baoyu.io/translations/the-prompt-engineering-playbook-for)[^3]**

标签：AI,Tools

AI 开发和 Vibe Coding 已经融入了工作之中。相信很多朋友已经能感觉到提示词的质量能影响 AI 输出的结果。即便大模型迭代到了今天，一个好的提示词仍然是必不可少的工具。

这篇文章介绍了一些提示词工程的小技巧，并给出了调试、开发、重构等几个场景。关键点依旧在于以下几点：
1. 提供丰富的上下文
2. 明确你的目标或问题
3. 利用角色或身份
4. 包含输入/输出示例或预期行为

我理解的核心就是要有“明确”的需求。无论是人还是 AI 都需要在明确地需求下才能开始工作，想象如果一个需求自己都没法做的话，那 AI 也是一样的。这里摘录了文中的小技巧备忘清单：

给 AI 代码助手的提示词技巧 - @addyosmani
| 技巧 | 提示词模板 | 目的 |
| --- | --- | --- |
| 角色提示 (Role Prompting) | "你是一位资深的 {某种语言} 开发者。请为了 {某个目标} 来审查这个函数。" | 模拟专家级的代码审查、调试或重构，获得更高质量的建议。 |
| 明确上下文 (Explicit Context Setup) | "问题是：{问题摘要}。代码如下。它本应 {预期行为}，但现在却 {实际行为}。这是为什么？" | 清晰地框定问题，避免 AI 给出泛泛而谈、流于表面的回答。 |
| 输入/输出示例 (Input/Output Examples) | "当输入为 {某个输入} 时，这个函数应该返回 {预期输出}。你能编写或修复这段代码吗？" | 通过具体示例来展示你的意图，引导 AI 智能体准确理解需求。 |
| 迭代式链条 (Iterative Chaining) | "第一步，生成组件的骨架代码。下一步，我们来添加状态管理。最后，处理 API 调用。" | 将复杂的大任务分解成连续的小步骤，避免因提示过于庞大或含糊而导致 AI 混乱。 |
| 模拟调试 (Debug with Simulation) | "请逐行过一遍这个函数。每个变量的值是什么？代码最有可能在哪里出错？" | 让 AI 智能体模拟代码的运行时行为，从而帮助你发现那些隐藏很深的 bug。 |
| 功能蓝图 (Feature Blueprinting) | "我正在构建 {某个功能}。需求是：{几点核心需求}。技术栈是：{所用技术}。请搭建出初始组件的脚手架，并解释你的选择。" | 借助 AI 主导的规划和脚手架能力，高效启动新功能的开发。 |
| 重构指导 (Code Refactor Guidance) | "请重构这段代码以提升 {某个目标}，例如 {可读性、性能、代码风格等}。请用注释来解释你做了哪些更改。" | 确保 AI 的代码重构与你的核心目标对齐，而不是进行随意的、不必要的修改。 |
| 寻求替代方案 (Ask for Alternatives) | "你能用函数式风格重写这段代码吗？如果用递归版本会是什么样子？" | 探索多种不同的实现路径，开阔思路，并丰富你的技术工具箱。 |
| 小黄鸭调试法 (Rubber Ducking) | "我是这样理解这个函数功能的：{你的解释}。我有什么遗漏吗？这个解释能暴露出什么 bug 吗？" | 让 AI 扮演“小黄鸭”的角色，通过向它解释来挑战你自己的理解，并发现逻辑上的矛盾之处。 |
| 约束锚定 (Constraint Anchoring) | "请避免使用 {例如：递归}，并严格遵守 {例如：ES6 语法，不使用外部库}。请为 {例如：内存占用} 进行优化。函数如下：" | 给 AI 设定明确的边界和限制，防止它“自由发挥”过度，或引入与项目不兼容的代码模式。 |

----

## 工具
**1、[Declutter your JavaScript & TypeScript projects](https://knip.dev/)[^6]**

标签：Node.js

检查项目中没用的 export 和依赖的 Node.js 工具库，适合对大项目/历史项目进行优化。使用起来也很方便，可以通过 npm 安装或者直接使用 npx 运行。

![](https://knip.dev/og/docs.webp)

----

## 参考文章:
- [1] Stop using .reverse().find(): meet findLast() - Matt Smith: https://allthingssmitty.com/2025/09/22/stop-using-reverse-find-meet-findlast/
- [2] Worker Threads in Node.js: A Complete Guide for Multithreading in JavaScript: https://nodesource.com/blog/worker-threads-nodejs-multithreading-in-javascript
- [3] 程序员的提示工程实战手册: https://baoyu.io/translations/the-prompt-engineering-playbook-for
- [4] Mastering NPX: A Cheatsheet for npm and Node.js Power Users: https://www.nodejs-security.com/blog/mastering-npx-cheatsheet-npm-nodejs-power-users
- [5] How Deno protects against npm exploits | Deno: https://deno.com/blog/deno-protects-npm-exploits
- [6] Declutter your JavaScript & TypeScript projects: https://knip.dev/